/*!
 * PhotoSwipe 5.3.7 - https://photoswipe.com
 * (c) 2023 Dmytro Semenov
 */ !(function (t, i) {
    "object" == typeof exports && "undefined" != typeof module
        ? (module.exports = i())
        : "function" == typeof define && define.amd
        ? define(i)
        : ((t =
              "undefined" != typeof globalThis
                  ? globalThis
                  : t || self).PhotoSwipe = i());
})(this, function () {
    "use strict";
    function t(t, i, e) {
        let s = document.createElement(i);
        return t && (s.className = t), e && e.appendChild(s), s;
    }
    function i(t, i) {
        return (t.x = i.x), (t.y = i.y), void 0 !== i.id && (t.id = i.id), t;
    }
    function e(t) {
        (t.x = Math.round(t.x)), (t.y = Math.round(t.y));
    }
    function s(t, i) {
        let e = Math.abs(t.x - i.x),
            s = Math.abs(t.y - i.y);
        return Math.sqrt(e * e + s * s);
    }
    function n(t, i) {
        return t.x === i.x && t.y === i.y;
    }
    function h(t, i, e) {
        return Math.min(Math.max(t, i), e);
    }
    function o(t, i, e) {
        let s = `translate3d(${t}px,${i || 0}px,0)`;
        return void 0 !== e && (s += ` scale3d(${e},${e},1)`), s;
    }
    function r(t, i, e, s) {
        t.style.transform = o(i, e, s);
    }
    function a(t, i, e, s) {
        t.style.transition = i
            ? `${i} ${e}ms ${s || "cubic-bezier(.4,0,.22,1)"}`
            : "none";
    }
    function l(t, i, e) {
        (t.style.width = "number" == typeof i ? `${i}px` : i),
            (t.style.height = "number" == typeof e ? `${e}px` : e);
    }
    let p = "loading",
        d = "loaded",
        c = "error";
    function m() {
        return !(!navigator.vendor || !navigator.vendor.match(/apple/i));
    }
    let u = !1;
    try {
        window.addEventListener(
            "test",
            null,
            Object.defineProperty({}, "passive", {
                get() {
                    u = !0;
                },
            })
        );
    } catch (g) {}
    function y(t, i) {
        if (t.getViewportSizeFn) {
            let e = t.getViewportSizeFn(t, i);
            if (e) return e;
        }
        return {
            x: document.documentElement.clientWidth,
            y: window.innerHeight,
        };
    }
    function $(t, i, e, s, n) {
        let h = 0;
        if (i.paddingFn) h = i.paddingFn(e, s, n)[t];
        else if (i.padding) h = i.padding[t];
        else {
            let o = "padding" + t[0].toUpperCase() + t.slice(1);
            i[o] && (h = i[o]);
        }
        return Number(h) || 0;
    }
    function v(t, i, e, s) {
        return {
            x: i.x - $("left", t, i, e, s) - $("right", t, i, e, s),
            y: i.y - $("top", t, i, e, s) - $("bottom", t, i, e, s),
        };
    }
    class w {
        constructor(t, i, e, s) {
            (this.pswp = s),
                (this.options = t),
                (this.itemData = i),
                (this.index = e),
                (this.panAreaSize = null),
                (this.elementSize = null),
                (this.fit = 1),
                (this.fill = 1),
                (this.vFill = 1),
                (this.initial = 1),
                (this.secondary = 1),
                (this.max = 1),
                (this.min = 1);
        }
        update(t, i, e) {
            let s = { x: t, y: i };
            (this.elementSize = s), (this.panAreaSize = e);
            let n = e.x / s.x,
                h = e.y / s.y;
            (this.fit = Math.min(1, n < h ? n : h)),
                (this.fill = Math.min(1, n > h ? n : h)),
                (this.vFill = Math.min(1, h)),
                (this.initial = this.l()),
                (this.secondary = this.u()),
                (this.max = Math.max(this.initial, this.secondary, this.p())),
                (this.min = Math.min(this.fit, this.initial, this.secondary)),
                this.pswp &&
                    this.pswp.dispatch("zoomLevelsUpdate", {
                        zoomLevels: this,
                        slideData: this.itemData,
                    });
        }
        m(t) {
            let i = this.options[t + "ZoomLevel"];
            if (i)
                return "function" == typeof i
                    ? i(this)
                    : "fill" === i
                    ? this.fill
                    : "fit" === i
                    ? this.fit
                    : Number(i);
        }
        u() {
            let t = this.m("secondary");
            return (
                t ||
                ((t = Math.min(1, 3 * this.fit)),
                this.elementSize &&
                    t * this.elementSize.x > 4e3 &&
                    (t = 4e3 / this.elementSize.x),
                t)
            );
        }
        l() {
            return this.m("initial") || this.fit;
        }
        p() {
            return this.m("max") || Math.max(1, 4 * this.fit);
        }
    }
    class f {
        constructor(i, e, s) {
            (this.data = i),
                (this.index = e),
                (this.pswp = s),
                (this.isActive = e === s.currIndex),
                (this.currentResolution = 0),
                (this.panAreaSize = { x: 0, y: 0 }),
                (this.pan = { x: 0, y: 0 }),
                (this.isFirstSlide = this.isActive && !s.opener.isOpen),
                (this.zoomLevels = new w(s.options, i, e, s)),
                this.pswp.dispatch("gettingData", {
                    slide: this,
                    data: this.data,
                    index: e,
                }),
                (this.content =
                    this.pswp.contentLoader.getContentBySlide(this)),
                (this.container = t("pswp__zoom-wrap", "div")),
                (this.holderElement = null),
                (this.currZoomLevel = 1),
                (this.width = this.content.width),
                (this.height = this.content.height),
                (this.heavyAppended = !1),
                (this.bounds = new (class t {
                    constructor(t) {
                        (this.slide = t),
                            (this.currZoomLevel = 1),
                            (this.center = { x: 0, y: 0 }),
                            (this.max = { x: 0, y: 0 }),
                            (this.min = { x: 0, y: 0 });
                    }
                    update(t) {
                        (this.currZoomLevel = t),
                            this.slide.width
                                ? (this.o("x"),
                                  this.o("y"),
                                  this.slide.pswp.dispatch("calcBounds", {
                                      slide: this.slide,
                                  }))
                                : this.reset();
                    }
                    o(t) {
                        let { pswp: i } = this.slide,
                            e =
                                this.slide["x" === t ? "width" : "height"] *
                                this.currZoomLevel,
                            s = $(
                                "x" === t ? "left" : "top",
                                i.options,
                                i.viewportSize,
                                this.slide.data,
                                this.slide.index
                            ),
                            n = this.slide.panAreaSize[t];
                        (this.center[t] = Math.round((n - e) / 2) + s),
                            (this.max[t] =
                                e > n ? Math.round(n - e) + s : this.center[t]),
                            (this.min[t] = e > n ? s : this.center[t]);
                    }
                    reset() {
                        (this.center.x = 0),
                            (this.center.y = 0),
                            (this.max.x = 0),
                            (this.max.y = 0),
                            (this.min.x = 0),
                            (this.min.y = 0);
                    }
                    correctPan(t, i) {
                        return h(i, this.max[t], this.min[t]);
                    }
                })(this)),
                (this.prevDisplayedWidth = -1),
                (this.prevDisplayedHeight = -1),
                this.pswp.dispatch("slideInit", { slide: this });
        }
        setIsActive(t) {
            t && !this.isActive
                ? this.activate()
                : !t && this.isActive && this.deactivate();
        }
        append(t) {
            (this.holderElement = t),
                (this.container.style.transformOrigin = "0 0"),
                this.data &&
                    (this.calculateSize(),
                    this.load(),
                    this.updateContentSize(),
                    this.appendHeavy(),
                    this.holderElement.appendChild(this.container),
                    this.zoomAndPanToInitial(),
                    this.pswp.dispatch("firstZoomPan", { slide: this }),
                    this.applyCurrentZoomPan(),
                    this.pswp.dispatch("afterSetContent", { slide: this }),
                    this.isActive && this.activate());
        }
        load() {
            this.content.load(!1),
                this.pswp.dispatch("slideLoad", { slide: this });
        }
        appendHeavy() {
            let { pswp: t } = this;
            !this.heavyAppended &&
                t.opener.isOpen &&
                !t.mainScroll.isShifted() &&
                (this.isActive, 1) &&
                (this.pswp.dispatch("appendHeavy", { slide: this })
                    .defaultPrevented ||
                    ((this.heavyAppended = !0),
                    this.content.append(),
                    this.pswp.dispatch("appendHeavyContent", { slide: this })));
        }
        activate() {
            (this.isActive = !0),
                this.appendHeavy(),
                this.content.activate(),
                this.pswp.dispatch("slideActivate", { slide: this });
        }
        deactivate() {
            (this.isActive = !1),
                this.content.deactivate(),
                this.currZoomLevel !== this.zoomLevels.initial &&
                    this.calculateSize(),
                (this.currentResolution = 0),
                this.zoomAndPanToInitial(),
                this.applyCurrentZoomPan(),
                this.updateContentSize(),
                this.pswp.dispatch("slideDeactivate", { slide: this });
        }
        destroy() {
            (this.content.hasSlide = !1),
                this.content.remove(),
                this.container.remove(),
                this.pswp.dispatch("slideDestroy", { slide: this });
        }
        resize() {
            this.currZoomLevel !== this.zoomLevels.initial && this.isActive
                ? (this.calculateSize(),
                  this.bounds.update(this.currZoomLevel),
                  this.panTo(this.pan.x, this.pan.y))
                : (this.calculateSize(),
                  (this.currentResolution = 0),
                  this.zoomAndPanToInitial(),
                  this.applyCurrentZoomPan(),
                  this.updateContentSize());
        }
        updateContentSize(t) {
            let i = this.currentResolution || this.zoomLevels.initial;
            if (!i) return;
            let e = Math.round(this.width * i) || this.pswp.viewportSize.x,
                s = Math.round(this.height * i) || this.pswp.viewportSize.y;
            (this.sizeChanged(e, s) || t) &&
                this.content.setDisplayedSize(e, s);
        }
        sizeChanged(t, i) {
            return (
                (t !== this.prevDisplayedWidth ||
                    i !== this.prevDisplayedHeight) &&
                ((this.prevDisplayedWidth = t),
                (this.prevDisplayedHeight = i),
                !0)
            );
        }
        getPlaceholderElement() {
            return this.content.placeholder?.element;
        }
        zoomTo(t, i, s, n) {
            let { pswp: o } = this;
            if (!this.isZoomable() || o.mainScroll.isShifted()) return;
            o.dispatch("beforeZoomTo", {
                destZoomLevel: t,
                centerPoint: i,
                transitionDuration: s,
            }),
                o.animations.stopAllPan();
            let r = this.currZoomLevel;
            n || (t = h(t, this.zoomLevels.min, this.zoomLevels.max)),
                this.setZoomLevel(t),
                (this.pan.x = this.calculateZoomToPanOffset("x", i, r)),
                (this.pan.y = this.calculateZoomToPanOffset("y", i, r)),
                e(this.pan);
            let a = () => {
                this.g(t), this.applyCurrentZoomPan();
            };
            s
                ? o.animations.startTransition({
                      isPan: !0,
                      name: "zoomTo",
                      target: this.container,
                      transform: this.getCurrentTransform(),
                      onComplete: a,
                      duration: s,
                      easing: o.options.easing,
                  })
                : a();
        }
        toggleZoom(t) {
            this.zoomTo(
                this.currZoomLevel === this.zoomLevels.initial
                    ? this.zoomLevels.secondary
                    : this.zoomLevels.initial,
                t,
                this.pswp.options.zoomAnimationDuration
            );
        }
        setZoomLevel(t) {
            (this.currZoomLevel = t), this.bounds.update(this.currZoomLevel);
        }
        calculateZoomToPanOffset(t, i, e) {
            if (0 == this.bounds.max[t] - this.bounds.min[t])
                return this.bounds.center[t];
            i || (i = this.pswp.getViewportCenterPoint()),
                e || (e = this.zoomLevels.initial);
            let s = this.currZoomLevel / e;
            return this.bounds.correctPan(t, (this.pan[t] - i[t]) * s + i[t]);
        }
        panTo(t, i) {
            (this.pan.x = this.bounds.correctPan("x", t)),
                (this.pan.y = this.bounds.correctPan("y", i)),
                this.applyCurrentZoomPan();
        }
        isPannable() {
            return (
                Boolean(this.width) && this.currZoomLevel > this.zoomLevels.fit
            );
        }
        isZoomable() {
            return Boolean(this.width) && this.content.isZoomable();
        }
        applyCurrentZoomPan() {
            this.v(this.pan.x, this.pan.y, this.currZoomLevel),
                this === this.pswp.currSlide &&
                    this.pswp.dispatch("zoomPanUpdate", { slide: this });
        }
        zoomAndPanToInitial() {
            (this.currZoomLevel = this.zoomLevels.initial),
                this.bounds.update(this.currZoomLevel),
                i(this.pan, this.bounds.center),
                this.pswp.dispatch("initialZoomPan", { slide: this });
        }
        v(t, i, e) {
            (e /= this.currentResolution || this.zoomLevels.initial),
                r(this.container, t, i, e);
        }
        calculateSize() {
            let { pswp: t } = this;
            i(
                this.panAreaSize,
                v(t.options, t.viewportSize, this.data, this.index)
            ),
                this.zoomLevels.update(
                    this.width,
                    this.height,
                    this.panAreaSize
                ),
                t.dispatch("calcSlideSize", { slide: this });
        }
        getCurrentTransform() {
            let t =
                this.currZoomLevel /
                (this.currentResolution || this.zoomLevels.initial);
            return o(this.pan.x, this.pan.y, t);
        }
        g(t) {
            t !== this.currentResolution &&
                ((this.currentResolution = t),
                this.updateContentSize(),
                this.pswp.dispatch("resolutionChanged"));
        }
    }
    function x(t, i, e) {
        return (t.x = (i.x + e.x) / 2), (t.y = (i.y + e.y) / 2), t;
    }
    function _(t) {
        return !!t.target.closest(".pswp__container");
    }
    let S = {
            Escape: 27,
            z: 90,
            ArrowLeft: 37,
            ArrowUp: 38,
            ArrowRight: 39,
            ArrowDown: 40,
            Tab: 9,
        },
        b = (t, i) => (i ? t : S[t]);
    class z {
        constructor(t) {
            this.props = t;
            let {
                target: i,
                onComplete: e,
                transform: s,
                onFinish: n = () => {},
                duration: h = 333,
                easing: o = "cubic-bezier(.4,0,.22,1)",
            } = t;
            this.onFinish = n;
            let r = s ? "transform" : "opacity",
                l = t[r] ?? "";
            (this.wt = i),
                (this.gt = e),
                (this.vt = !1),
                (this.yt = this.yt.bind(this)),
                (this._t = setTimeout(() => {
                    a(i, r, h, o),
                        (this._t = setTimeout(() => {
                            i.addEventListener("transitionend", this.yt, !1),
                                i.addEventListener(
                                    "transitioncancel",
                                    this.yt,
                                    !1
                                ),
                                (this._t = setTimeout(() => {
                                    this.xt();
                                }, h + 500)),
                                (i.style[r] = l);
                        }, 30));
                }, 0));
        }
        yt(t) {
            t.target === this.wt && this.xt();
        }
        xt() {
            this.vt || ((this.vt = !0), this.onFinish(), this.gt && this.gt());
        }
        destroy() {
            this._t && clearTimeout(this._t),
                a(this.wt),
                this.wt.removeEventListener("transitionend", this.yt, !1),
                this.wt.removeEventListener("transitioncancel", this.yt, !1),
                this.vt || this.xt();
        }
    }
    class L {
        constructor(t) {
            (this.props = t), (this.Mt = 0);
            let {
                start: i,
                end: e,
                velocity: s,
                onUpdate: n,
                onComplete: h,
                onFinish: o = () => {},
                dampingRatio: r,
                naturalFrequency: a,
            } = t;
            this.onFinish = o;
            let l = new (class t {
                    constructor(t, i, e) {
                        (this.velocity = 1e3 * t),
                            (this.bt = i || 0.75),
                            (this.St = e || 12),
                            (this.zt = this.St),
                            this.bt < 1 &&
                                (this.zt *= Math.sqrt(1 - this.bt * this.bt));
                    }
                    easeFrame(t, i) {
                        let e,
                            s = 0;
                        i /= 1e3;
                        let n = Math.E ** (-this.bt * this.St * i);
                        if (1 === this.bt)
                            (e = this.velocity + this.St * t),
                                (s = (t + e * i) * n),
                                (this.velocity = -(s * this.St) + e * n);
                        else if (this.bt < 1) {
                            e =
                                (1 / this.zt) *
                                (this.bt * this.St * t + this.velocity);
                            let h = Math.cos(this.zt * i),
                                o = Math.sin(this.zt * i);
                            (s = n * (t * h + e * o)),
                                (this.velocity =
                                    -(s * this.St) * this.bt +
                                    n * (-this.zt * t * o + this.zt * e * h));
                        }
                        return s;
                    }
                })(s, r, a),
                p = Date.now(),
                d = i - e,
                c = () => {
                    this.Mt &&
                        (1 > Math.abs((d = l.easeFrame(d, Date.now() - p))) &&
                        50 > Math.abs(l.velocity)
                            ? (n(e), h && h(), this.onFinish())
                            : ((p = Date.now()),
                              n(d + e),
                              (this.Mt = requestAnimationFrame(c))));
                };
            this.Mt = requestAnimationFrame(c);
        }
        destroy() {
            this.Mt >= 0 && cancelAnimationFrame(this.Mt), (this.Mt = 0);
        }
    }
    class I {
        constructor(t) {
            (this.pswp = t),
                t.events.add(t.element, "wheel", this.Ct.bind(this));
        }
        Ct(t) {
            t.preventDefault();
            let { currSlide: i } = this.pswp,
                { deltaX: e, deltaY: s } = t;
            if (
                i &&
                !this.pswp.dispatch("wheel", { originalEvent: t })
                    .defaultPrevented
            ) {
                if (t.ctrlKey || this.pswp.options.wheelToZoom) {
                    if (i.isZoomable()) {
                        let n = -s;
                        1 === t.deltaMode
                            ? (n *= 0.05)
                            : (n *= t.deltaMode ? 1 : 0.002),
                            (n = 2 ** n);
                        let h = i.currZoomLevel * n;
                        i.zoomTo(h, { x: t.clientX, y: t.clientY });
                    }
                } else
                    i.isPannable() &&
                        (1 === t.deltaMode && ((e *= 18), (s *= 18)),
                        i.panTo(i.pan.x - e, i.pan.y - s));
            }
        }
    }
    class P {
        constructor(i, e) {
            let s = e.name || e.className,
                n = e.html;
            if (!1 === i.options[s]) return;
            "string" == typeof i.options[s + "SVG"] &&
                (n = i.options[s + "SVG"]),
                i.dispatch("uiElementCreate", { data: e });
            let h = "";
            e.isButton
                ? ((h += "pswp__button "),
                  (h += e.className || `pswp__button--${e.name}`))
                : (h += e.className || `pswp__${e.name}`);
            let o = e.isButton ? e.tagName || "button" : e.tagName || "div";
            o = o.toLowerCase();
            let r = t(h, o);
            if (e.isButton) {
                "button" === o && (r.type = "button");
                let { title: a } = e,
                    { ariaLabel: l } = e;
                "string" == typeof i.options[s + "Title"] &&
                    (a = i.options[s + "Title"]),
                    a && (r.title = a);
                let p = l || a;
                p && r.setAttribute("aria-label", p);
            }
            (r.innerHTML = (function (t) {
                if ("string" == typeof t) return t;
                if (!t || !t.isCustomSVG) return "";
                let i = t,
                    e =
                        '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
                return (
                    (e = e.split("%d").join(i.size || 32)),
                    i.outlineID &&
                        (e +=
                            '<use class="pswp__icn-shadow" xlink:href="#' +
                            i.outlineID +
                            '"/>'),
                    (e += i.inner),
                    (e += "</svg>")
                );
            })(n)),
                e.onInit && e.onInit(r, i),
                e.onClick &&
                    (r.onclick = (t) => {
                        "string" == typeof e.onClick
                            ? i[e.onClick]()
                            : "function" == typeof e.onClick &&
                              e.onClick(t, r, i);
                    });
            let d = e.appendTo || "bar",
                c = i.element;
            "bar" === d
                ? (i.topBar ||
                      (i.topBar = t(
                          "pswp__top-bar pswp__hide-on-close",
                          "div",
                          i.scrollWrap
                      )),
                  (c = i.topBar))
                : (r.classList.add("pswp__hide-on-close"),
                  "wrapper" === d && (c = i.scrollWrap)),
                c?.appendChild(i.applyFilters("uiElement", r, e));
        }
    }
    function C(t, i, e) {
        t.classList.add("pswp__button--arrow"),
            t.setAttribute("aria-controls", "pswp__items"),
            i.on("change", () => {
                i.options.loop ||
                    (t.disabled = e
                        ? !(i.currIndex < i.getNumItems() - 1)
                        : !(i.currIndex > 0));
            });
    }
    let A = {
            name: "arrowPrev",
            className: "pswp__button--arrow--prev",
            title: "Previous",
            order: 10,
            isButton: !0,
            appendTo: "wrapper",
            html: {
                isCustomSVG: !0,
                size: 60,
                inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
                outlineID: "pswp__icn-arrow",
            },
            onClick: "prev",
            onInit: C,
        },
        D = {
            name: "arrowNext",
            className: "pswp__button--arrow--next",
            title: "Next",
            order: 11,
            isButton: !0,
            appendTo: "wrapper",
            html: {
                isCustomSVG: !0,
                size: 60,
                inner: '<use xlink:href="#pswp__icn-arrow"/>',
                outlineID: "pswp__icn-arrow",
            },
            onClick: "next",
            onInit(t, i) {
                C(t, i, !0);
            },
        },
        Z = {
            name: "close",
            title: "Close",
            order: 20,
            isButton: !0,
            html: {
                isCustomSVG: !0,
                inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
                outlineID: "pswp__icn-close",
            },
            onClick: "close",
        },
        T = {
            name: "zoom",
            title: "Zoom",
            order: 10,
            isButton: !0,
            html: {
                isCustomSVG: !0,
                inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/><path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/><path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
                outlineID: "pswp__icn-zoom",
            },
            onClick: "toggleZoom",
        },
        O = {
            name: "preloader",
            appendTo: "bar",
            order: 7,
            html: {
                isCustomSVG: !0,
                inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
                outlineID: "pswp__icn-loading",
            },
            onInit(t, i) {
                let e,
                    s = null,
                    n = (i) => {
                        var s, n;
                        e !== i &&
                            ((e = i),
                            (s = "active"),
                            (n = i),
                            t.classList.toggle("pswp__preloader--" + s, n));
                    },
                    h = () => {
                        if (!i.currSlide?.content.isLoading())
                            return (
                                n(!1), void (s && (clearTimeout(s), (s = null)))
                            );
                        s ||
                            (s = setTimeout(() => {
                                n(Boolean(i.currSlide?.content.isLoading())),
                                    (s = null);
                            }, i.options.preloaderDelay));
                    };
                i.on("change", h),
                    i.on("loadComplete", (t) => {
                        i.currSlide === t.slide && h();
                    }),
                    i.ui && (i.ui.updatePreloaderVisibility = h);
            },
        },
        E = {
            name: "counter",
            order: 5,
            onInit(t, i) {
                i.on("change", () => {
                    t.innerText =
                        i.currIndex +
                        1 +
                        i.options.indexIndicatorSep +
                        i.getNumItems();
                });
            },
        };
    function F(t, i) {
        t.classList.toggle("pswp--zoomed-in", i);
    }
    class B {
        constructor(t) {
            (this.pswp = t),
                (this.isRegistered = !1),
                (this.uiElementsData = []),
                (this.items = []),
                (this.updatePreloaderVisibility = () => {}),
                (this.Tt = void 0);
        }
        init() {
            let { pswp: t } = this;
            (this.isRegistered = !1),
                (this.uiElementsData = [Z, A, D, T, O, E]),
                t.dispatch("uiRegister"),
                this.uiElementsData.sort(
                    (t, i) => (t.order || 0) - (i.order || 0)
                ),
                (this.items = []),
                (this.isRegistered = !0),
                this.uiElementsData.forEach((t) => {
                    this.registerElement(t);
                }),
                t.on("change", () => {
                    t.element?.classList.toggle(
                        "pswp--one-slide",
                        1 === t.getNumItems()
                    );
                }),
                t.on("zoomPanUpdate", () => this.At());
        }
        registerElement(t) {
            this.isRegistered
                ? this.items.push(new P(this.pswp, t))
                : this.uiElementsData.push(t);
        }
        At() {
            let { template: t, currSlide: i, options: e } = this.pswp;
            if (this.pswp.opener.isClosing || !t || !i) return;
            let { currZoomLevel: s } = i;
            if (
                (this.pswp.opener.isOpen || (s = i.zoomLevels.initial),
                s === this.Tt)
            )
                return;
            this.Tt = s;
            let n = i.zoomLevels.initial - i.zoomLevels.secondary;
            if (0.01 > Math.abs(n) || !i.isZoomable())
                return F(t, !1), void t.classList.remove("pswp--zoom-allowed");
            t.classList.add("pswp--zoom-allowed"),
                F(
                    t,
                    (s === i.zoomLevels.initial
                        ? i.zoomLevels.secondary
                        : i.zoomLevels.initial) <= s
                ),
                ("zoom" !== e.imageClickAction &&
                    "zoom-or-close" !== e.imageClickAction) ||
                    t.classList.add("pswp--click-to-zoom");
        }
    }
    class k {
        constructor(t, i) {
            (this.type = t),
                (this.defaultPrevented = !1),
                i && Object.assign(this, i);
        }
        preventDefault() {
            this.defaultPrevented = !0;
        }
    }
    class H {
        constructor(i, e) {
            if (
                ((this.element = t(
                    "pswp__img pswp__img--placeholder",
                    i ? "img" : "div",
                    e
                )),
                i)
            ) {
                let s = this.element;
                (s.decoding = "async"),
                    (s.alt = ""),
                    (s.src = i),
                    s.setAttribute("role", "presentation");
            }
            this.element.setAttribute("aria-hidden", "true");
        }
        setDisplayedSize(t, i) {
            this.element &&
                ("IMG" === this.element.tagName
                    ? (l(this.element, 250, "auto"),
                      (this.element.style.transformOrigin = "0 0"),
                      (this.element.style.transform = o(0, 0, t / 250)))
                    : l(this.element, t, i));
        }
        destroy() {
            this.element?.parentNode && this.element.remove(),
                (this.element = null);
        }
    }
    class N {
        constructor(t, i, e) {
            (this.instance = i),
                (this.data = t),
                (this.index = e),
                (this.element = void 0),
                (this.placeholder = void 0),
                (this.slide = void 0),
                (this.displayedImageWidth = 0),
                (this.displayedImageHeight = 0),
                (this.width =
                    Number(this.data.w) || Number(this.data.width) || 0),
                (this.height =
                    Number(this.data.h) || Number(this.data.height) || 0),
                (this.isAttached = !1),
                (this.hasSlide = !1),
                (this.isDecoding = !1),
                (this.state = "idle"),
                this.data.type
                    ? (this.type = this.data.type)
                    : this.data.src
                    ? (this.type = "image")
                    : (this.type = "html"),
                this.instance.dispatch("contentInit", { content: this });
        }
        removePlaceholder() {
            this.placeholder &&
                !this.keepPlaceholder() &&
                setTimeout(() => {
                    this.placeholder &&
                        (this.placeholder.destroy(),
                        (this.placeholder = void 0));
                }, 1e3);
        }
        load(i, e) {
            if (this.slide && this.usePlaceholder()) {
                if (this.placeholder) {
                    let s = this.placeholder.element;
                    s && !s.parentElement && this.slide.container.prepend(s);
                } else {
                    let n = this.instance.applyFilters(
                        "placeholderSrc",
                        !(!this.data.msrc || !this.slide.isFirstSlide) &&
                            this.data.msrc,
                        this
                    );
                    this.placeholder = new H(n, this.slide.container);
                }
            }
            (this.element && !e) ||
                this.instance.dispatch("contentLoad", {
                    content: this,
                    isLazy: i,
                }).defaultPrevented ||
                (this.isImageContent()
                    ? ((this.element = t("pswp__img", "img")),
                      this.displayedImageWidth && this.loadImage(i))
                    : ((this.element = t("pswp__content", "div")),
                      (this.element.innerHTML = this.data.html || "")),
                e && this.slide && this.slide.updateContentSize(!0));
        }
        loadImage(t) {
            if (
                !this.isImageContent() ||
                !this.element ||
                this.instance.dispatch("contentLoadImage", {
                    content: this,
                    isLazy: t,
                }).defaultPrevented
            )
                return;
            let i = this.element;
            this.updateSrcsetSizes(),
                this.data.srcset && (i.srcset = this.data.srcset),
                (i.src = this.data.src ?? ""),
                (i.alt = this.data.alt ?? ""),
                (this.state = p),
                i.complete
                    ? this.onLoaded()
                    : ((i.onload = () => {
                          this.onLoaded();
                      }),
                      (i.onerror = () => {
                          this.onError();
                      }));
        }
        setSlide(t) {
            (this.slide = t), (this.hasSlide = !0), (this.instance = t.pswp);
        }
        onLoaded() {
            (this.state = d),
                this.slide &&
                    this.element &&
                    (this.instance.dispatch("loadComplete", {
                        slide: this.slide,
                        content: this,
                    }),
                    this.slide.isActive &&
                        this.slide.heavyAppended &&
                        !this.element.parentNode &&
                        (this.append(), this.slide.updateContentSize(!0)),
                    (this.state !== d && this.state !== c) ||
                        this.removePlaceholder());
        }
        onError() {
            (this.state = c),
                this.slide &&
                    (this.displayError(),
                    this.instance.dispatch("loadComplete", {
                        slide: this.slide,
                        isError: !0,
                        content: this,
                    }),
                    this.instance.dispatch("loadError", {
                        slide: this.slide,
                        content: this,
                    }));
        }
        isLoading() {
            return this.instance.applyFilters(
                "isContentLoading",
                this.state === p,
                this
            );
        }
        isError() {
            return this.state === c;
        }
        isImageContent() {
            return "image" === this.type;
        }
        setDisplayedSize(t, i) {
            if (
                this.element &&
                (this.placeholder && this.placeholder.setDisplayedSize(t, i),
                !this.instance.dispatch("contentResize", {
                    content: this,
                    width: t,
                    height: i,
                }).defaultPrevented &&
                    (l(this.element, t, i),
                    this.isImageContent() && !this.isError()))
            ) {
                let e = !this.displayedImageWidth && t;
                (this.displayedImageWidth = t),
                    (this.displayedImageHeight = i),
                    e ? this.loadImage(!1) : this.updateSrcsetSizes(),
                    this.slide &&
                        this.instance.dispatch("imageSizeChange", {
                            slide: this.slide,
                            width: t,
                            height: i,
                            content: this,
                        });
            }
        }
        isZoomable() {
            return this.instance.applyFilters(
                "isContentZoomable",
                this.isImageContent() && this.state !== c,
                this
            );
        }
        updateSrcsetSizes() {
            if (!this.isImageContent() || !this.element || !this.data.srcset)
                return;
            let t = this.element,
                i = this.instance.applyFilters(
                    "srcsetSizesWidth",
                    this.displayedImageWidth,
                    this
                );
            (!t.dataset.largestUsedSize ||
                i > parseInt(t.dataset.largestUsedSize, 10)) &&
                ((t.sizes = i + "px"), (t.dataset.largestUsedSize = String(i)));
        }
        usePlaceholder() {
            return this.instance.applyFilters(
                "useContentPlaceholder",
                this.isImageContent(),
                this
            );
        }
        lazyLoad() {
            this.instance.dispatch("contentLazyLoad", { content: this })
                .defaultPrevented || this.load(!0);
        }
        keepPlaceholder() {
            return this.instance.applyFilters(
                "isKeepingPlaceholder",
                this.isLoading(),
                this
            );
        }
        destroy() {
            (this.hasSlide = !1),
                (this.slide = void 0),
                this.instance.dispatch("contentDestroy", { content: this })
                    .defaultPrevented ||
                    (this.remove(),
                    this.placeholder &&
                        (this.placeholder.destroy(),
                        (this.placeholder = void 0)),
                    this.isImageContent() &&
                        this.element &&
                        ((this.element.onload = null),
                        (this.element.onerror = null),
                        (this.element = void 0)));
        }
        displayError() {
            if (this.slide) {
                let i = t("pswp__error-msg", "div");
                (i.innerText = this.instance.options?.errorMsg ?? ""),
                    (i = this.instance.applyFilters(
                        "contentErrorElement",
                        i,
                        this
                    )),
                    (this.element = t(
                        "pswp__content pswp__error-msg-container",
                        "div"
                    )),
                    this.element.appendChild(i),
                    (this.slide.container.innerText = ""),
                    this.slide.container.appendChild(this.element),
                    this.slide.updateContentSize(!0),
                    this.removePlaceholder();
            }
        }
        append() {
            if (this.isAttached || !this.element) return;
            if (((this.isAttached = !0), this.state === c))
                return void this.displayError();
            if (
                this.instance.dispatch("contentAppend", { content: this })
                    .defaultPrevented
            )
                return;
            let t = "decode" in this.element;
            this.isImageContent()
                ? t && this.slide && (!this.slide.isActive || m())
                    ? ((this.isDecoding = !0),
                      this.element
                          .decode()
                          .catch(() => {})
                          .finally(() => {
                              (this.isDecoding = !1), this.appendImage();
                          }))
                    : this.appendImage()
                : this.slide &&
                  !this.element.parentNode &&
                  this.slide.container.appendChild(this.element);
        }
        activate() {
            !this.instance.dispatch("contentActivate", { content: this })
                .defaultPrevented &&
                this.slide &&
                (this.isImageContent() && this.isDecoding && !m()
                    ? this.appendImage()
                    : this.isError() && this.load(!1, !0),
                this.slide.holderElement &&
                    this.slide.holderElement.setAttribute(
                        "aria-hidden",
                        "false"
                    ));
        }
        deactivate() {
            this.instance.dispatch("contentDeactivate", { content: this }),
                this.slide &&
                    this.slide.holderElement &&
                    this.slide.holderElement.setAttribute(
                        "aria-hidden",
                        "true"
                    );
        }
        remove() {
            (this.isAttached = !1),
                this.instance.dispatch("contentRemove", { content: this })
                    .defaultPrevented ||
                    (this.element &&
                        this.element.parentNode &&
                        this.element.remove(),
                    this.placeholder &&
                        this.placeholder.element &&
                        this.placeholder.element.remove());
        }
        appendImage() {
            this.isAttached &&
                (this.instance.dispatch("contentAppendImage", { content: this })
                    .defaultPrevented ||
                    (this.slide &&
                        this.element &&
                        !this.element.parentNode &&
                        this.slide.container.appendChild(this.element),
                    (this.state !== d && this.state !== c) ||
                        this.removePlaceholder()));
        }
    }
    function W(t, i, e) {
        let s = i.createContentFromData(t, e),
            n,
            { options: h } = i;
        if (h) {
            let o;
            (n = new w(h, t, -1)), (o = i.pswp ? i.pswp.viewportSize : y(h, i));
            let r = v(h, o, t, e);
            n.update(s.width, s.height, r);
        }
        return (
            s.lazyLoad(),
            n &&
                s.setDisplayedSize(
                    Math.ceil(s.width * n.initial),
                    Math.ceil(s.height * n.initial)
                ),
            s
        );
    }
    let M = {
        allowPanToNext: !0,
        spacing: 0.1,
        loop: !0,
        pinchToClose: !0,
        closeOnVerticalDrag: !0,
        hideAnimationDuration: 333,
        showAnimationDuration: 333,
        zoomAnimationDuration: 333,
        escKey: !0,
        arrowKeys: !0,
        returnFocus: !0,
        maxWidthToAnimate: 4e3,
        clickToCloseNonZoomable: !0,
        imageClickAction: "zoom-or-close",
        bgClickAction: "close",
        tapAction: "toggle-controls",
        doubleTapAction: "zoom",
        indexIndicatorSep: " / ",
        preloaderDelay: 2e3,
        bgOpacity: 0.8,
        index: 0,
        errorMsg: "The image cannot be loaded",
        preload: [1, 2],
        easing: "cubic-bezier(.4,0,.22,1)",
    };
    return class extends class extends class {
        constructor() {
            (this.Yt = {}),
                (this.Jt = {}),
                (this.pswp = void 0),
                (this.options = void 0);
        }
        addFilter(t, i, e = 100) {
            this.Jt[t] || (this.Jt[t] = []),
                this.Jt[t]?.push({ fn: i, priority: e }),
                this.Jt[t]?.sort((t, i) => t.priority - i.priority),
                this.pswp?.addFilter(t, i, e);
        }
        removeFilter(t, i) {
            this.Jt[t] && (this.Jt[t] = this.Jt[t].filter((t) => t.fn !== i)),
                this.pswp && this.pswp.removeFilter(t, i);
        }
        applyFilters(t, ...i) {
            return (
                this.Jt[t]?.forEach((t) => {
                    i[0] = t.fn.apply(this, i);
                }),
                i[0]
            );
        }
        on(t, i) {
            this.Yt[t] || (this.Yt[t] = []),
                this.Yt[t]?.push(i),
                this.pswp?.on(t, i);
        }
        off(t, i) {
            this.Yt[t] && (this.Yt[t] = this.Yt[t].filter((t) => i !== t)),
                this.pswp?.off(t, i);
        }
        dispatch(t, i) {
            if (this.pswp) return this.pswp.dispatch(t, i);
            let e = new k(t, i);
            return (
                this.Yt[t]?.forEach((t) => {
                    t.call(this, e);
                }),
                e
            );
        }
    } {
        getNumItems() {
            let t = 0,
                i = this.options?.dataSource;
            i && "length" in i
                ? (t = i.length)
                : i &&
                  "gallery" in i &&
                  (i.items || (i.items = this.Qt(i.gallery)),
                  i.items && (t = i.items.length));
            let e = this.dispatch("numItems", { dataSource: i, numItems: t });
            return this.applyFilters("numItems", e.numItems, i);
        }
        createContentFromData(t, i) {
            return new N(t, this, i);
        }
        getItemData(t) {
            let i = this.options?.dataSource,
                e = {};
            Array.isArray(i)
                ? (e = i[t])
                : i &&
                  "gallery" in i &&
                  (i.items || (i.items = this.Qt(i.gallery)), (e = i.items[t]));
            let s = e;
            s instanceof Element && (s = this.ti(s));
            let n = this.dispatch("itemData", { itemData: s || {}, index: t });
            return this.applyFilters("itemData", n.itemData, t);
        }
        Qt(t) {
            return this.options?.children || this.options?.childSelector
                ? (function (t, i, e = document) {
                      let s = [];
                      if (t instanceof Element) s = [t];
                      else if (t instanceof NodeList || Array.isArray(t))
                          s = Array.from(t);
                      else {
                          let n = "string" == typeof t ? t : i;
                          n && (s = Array.from(e.querySelectorAll(n)));
                      }
                      return s;
                  })(this.options.children, this.options.childSelector, t) || []
                : [t];
        }
        ti(t) {
            let i = { element: t },
                e = "A" === t.tagName ? t : t.querySelector("a");
            if (e) {
                (i.src = e.dataset.pswpSrc || e.href),
                    e.dataset.pswpSrcset && (i.srcset = e.dataset.pswpSrcset),
                    (i.width = e.dataset.pswpWidth
                        ? parseInt(e.dataset.pswpWidth, 10)
                        : 0),
                    (i.height = e.dataset.pswpHeight
                        ? parseInt(e.dataset.pswpHeight, 10)
                        : 0),
                    (i.w = i.width),
                    (i.h = i.height),
                    e.dataset.pswpType && (i.type = e.dataset.pswpType);
                let s = t.querySelector("img");
                s &&
                    ((i.msrc = s.currentSrc || s.src),
                    (i.alt = s.getAttribute("alt") ?? "")),
                    (e.dataset.pswpCropped || e.dataset.cropped) &&
                        (i.thumbCropped = !0);
            }
            return this.applyFilters("domItemData", i, t, e);
        }
        lazyLoadData(t, i) {
            return W(t, this, i);
        }
    } {
        constructor(a) {
            super(),
                (this.options = this.ii(a || {})),
                (this.offset = { x: 0, y: 0 }),
                (this.si = { x: 0, y: 0 }),
                (this.viewportSize = { x: 0, y: 0 }),
                (this.bgOpacity = 1),
                (this.currIndex = 0),
                (this.potentialIndex = 0),
                (this.isOpen = !1),
                (this.isDestroying = !1),
                (this.hasMouse = !1),
                (this.hi = {}),
                (this.Gt = void 0),
                (this.topBar = void 0),
                (this.element = void 0),
                (this.template = void 0),
                (this.container = void 0),
                (this.scrollWrap = void 0),
                (this.currSlide = void 0),
                (this.events = new (class t {
                    constructor() {
                        this.t = [];
                    }
                    add(t, i, e, s) {
                        this.i(t, i, e, s);
                    }
                    remove(t, i, e, s) {
                        this.i(t, i, e, s, !0);
                    }
                    removeAll() {
                        this.t.forEach((t) => {
                            this.i(
                                t.target,
                                t.type,
                                t.listener,
                                t.passive,
                                !0,
                                !0
                            );
                        }),
                            (this.t = []);
                    }
                    i(t, i, e, s, n, h) {
                        if (!t) return;
                        let o = n ? "removeEventListener" : "addEventListener";
                        i.split(" ").forEach((i) => {
                            if (i) {
                                h ||
                                    (n
                                        ? (this.t = this.t.filter(
                                              (s) =>
                                                  s.type !== i ||
                                                  s.listener !== e ||
                                                  s.target !== t
                                          ))
                                        : this.t.push({
                                              target: t,
                                              type: i,
                                              listener: e,
                                              passive: s,
                                          }));
                                let r = !!u && { passive: s || !1 };
                                t[o](i, e, r);
                            }
                        });
                    }
                })()),
                (this.animations = new (class t {
                    constructor() {
                        this.activeAnimations = [];
                    }
                    startSpring(t) {
                        this.Pt(t, !0);
                    }
                    startTransition(t) {
                        this.Pt(t);
                    }
                    Pt(t, i) {
                        let e = i ? new L(t) : new z(t);
                        return (
                            this.activeAnimations.push(e),
                            (e.onFinish = () => this.stop(e)),
                            e
                        );
                    }
                    stop(t) {
                        t.destroy();
                        let i = this.activeAnimations.indexOf(t);
                        i > -1 && this.activeAnimations.splice(i, 1);
                    }
                    stopAll() {
                        this.activeAnimations.forEach((t) => {
                            t.destroy();
                        }),
                            (this.activeAnimations = []);
                    }
                    stopAllPan() {
                        this.activeAnimations = this.activeAnimations.filter(
                            (t) => !t.props.isPan || (t.destroy(), !1)
                        );
                    }
                    stopMainScroll() {
                        this.activeAnimations = this.activeAnimations.filter(
                            (t) => !t.props.isMainScroll || (t.destroy(), !1)
                        );
                    }
                    isPanRunning() {
                        return this.activeAnimations.some((t) => t.props.isPan);
                    }
                })()),
                (this.mainScroll = new (class i {
                    constructor(t) {
                        (this.pswp = t),
                            (this.x = 0),
                            (this.slideWidth = 0),
                            (this.ot = 0),
                            (this.rt = 0),
                            (this.ct = -1),
                            (this.itemHolders = []);
                    }
                    resize(t) {
                        let { pswp: i } = this,
                            e = Math.round(
                                i.viewportSize.x +
                                    i.viewportSize.x * i.options.spacing
                            ),
                            s = e !== this.slideWidth;
                        s &&
                            ((this.slideWidth = e),
                            this.moveTo(this.getCurrSlideX())),
                            this.itemHolders.forEach((i, e) => {
                                s && r(i.el, (e + this.ct) * this.slideWidth),
                                    t && i.slide && i.slide.resize();
                            });
                    }
                    resetPosition() {
                        (this.ot = 0),
                            (this.rt = 0),
                            (this.slideWidth = 0),
                            (this.ct = -1);
                    }
                    appendHolders() {
                        this.itemHolders = [];
                        for (let i = 0; i < 3; i++) {
                            let e = t("pswp__item", "div", this.pswp.container);
                            e.setAttribute("role", "group"),
                                e.setAttribute("aria-roledescription", "slide"),
                                e.setAttribute("aria-hidden", "true"),
                                (e.style.display = 1 === i ? "block" : "none"),
                                this.itemHolders.push({ el: e });
                        }
                    }
                    canBeSwiped() {
                        return this.pswp.getNumItems() > 1;
                    }
                    moveIndexBy(t, i, e) {
                        let { pswp: s } = this,
                            n = s.potentialIndex + t,
                            h = s.getNumItems();
                        if (s.canLoop()) {
                            n = s.getLoopedIndex(n);
                            let o = (t + h) % h;
                            t = o <= h / 2 ? o : o - h;
                        } else
                            n < 0 ? (n = 0) : n >= h && (n = h - 1),
                                (t = n - s.potentialIndex);
                        (s.potentialIndex = n),
                            (this.ot -= t),
                            s.animations.stopMainScroll();
                        let r = this.getCurrSlideX();
                        if (i) {
                            s.animations.startSpring({
                                isMainScroll: !0,
                                start: this.x,
                                end: r,
                                velocity: e || 0,
                                naturalFrequency: 30,
                                dampingRatio: 1,
                                onUpdate: (t) => {
                                    this.moveTo(t);
                                },
                                onComplete: () => {
                                    this.updateCurrItem(), s.appendHeavy();
                                },
                            });
                            let a = s.potentialIndex - s.currIndex;
                            if (s.canLoop()) {
                                let l = (a + h) % h;
                                a = l <= h / 2 ? l : l - h;
                            }
                            Math.abs(a) > 1 && this.updateCurrItem();
                        } else this.moveTo(r), this.updateCurrItem();
                        return Boolean(t);
                    }
                    getCurrSlideX() {
                        return this.slideWidth * this.ot;
                    }
                    isShifted() {
                        return this.x !== this.getCurrSlideX();
                    }
                    updateCurrItem() {
                        let { pswp: t } = this,
                            i = this.rt - this.ot;
                        if (!i) return;
                        (this.rt = this.ot), (t.currIndex = t.potentialIndex);
                        let e,
                            s = Math.abs(i);
                        s >= 3 && ((this.ct += i + (i > 0 ? -3 : 3)), (s = 3));
                        for (let n = 0; n < s; n++)
                            i > 0
                                ? (e = this.itemHolders.shift()) &&
                                  ((this.itemHolders[2] = e),
                                  this.ct++,
                                  r(e.el, (this.ct + 2) * this.slideWidth),
                                  t.setContent(e, t.currIndex - s + n + 2))
                                : (e = this.itemHolders.pop()) &&
                                  (this.itemHolders.unshift(e),
                                  this.ct--,
                                  r(e.el, this.ct * this.slideWidth),
                                  t.setContent(e, t.currIndex + s - n - 2));
                        Math.abs(this.ct) > 50 &&
                            !this.isShifted() &&
                            (this.resetPosition(), this.resize()),
                            t.animations.stopAllPan(),
                            this.itemHolders.forEach((t, i) => {
                                t.slide && t.slide.setIsActive(1 === i);
                            }),
                            (t.currSlide = this.itemHolders[1]?.slide),
                            t.contentLoader.updateLazy(i),
                            t.currSlide && t.currSlide.applyCurrentZoomPan(),
                            t.dispatch("change");
                    }
                    moveTo(t, i) {
                        if (!this.pswp.canLoop() && i) {
                            let e =
                                (this.slideWidth * this.ot - t) /
                                this.slideWidth;
                            e += this.pswp.currIndex;
                            let s = Math.round(t - this.x);
                            ((e < 0 && s > 0) ||
                                (e >= this.pswp.getNumItems() - 1 && s < 0)) &&
                                (t = this.x + 0.35 * s);
                        }
                        (this.x = t),
                            this.pswp.container && r(this.pswp.container, t),
                            this.pswp.dispatch("moveMainScroll", {
                                x: t,
                                dragging: i ?? !1,
                            });
                    }
                })(this)),
                (this.gestures = new (class t {
                    constructor(t) {
                        (this.pswp = t),
                            (this.dragAxis = null),
                            (this.p1 = { x: 0, y: 0 }),
                            (this.p2 = { x: 0, y: 0 }),
                            (this.prevP1 = { x: 0, y: 0 }),
                            (this.prevP2 = { x: 0, y: 0 }),
                            (this.startP1 = { x: 0, y: 0 }),
                            (this.startP2 = { x: 0, y: 0 }),
                            (this.velocity = { x: 0, y: 0 }),
                            (this.Z = { x: 0, y: 0 }),
                            (this.B = { x: 0, y: 0 }),
                            (this.F = 0),
                            (this.O = []),
                            (this.R = "ontouchstart" in window),
                            (this.N = !!window.PointerEvent),
                            (this.supportsTouch =
                                this.R ||
                                (this.N && navigator.maxTouchPoints > 1)),
                            (this.F = 0),
                            (this.U = 0),
                            (this.V = !1),
                            (this.isMultitouch = !1),
                            (this.isDragging = !1),
                            (this.isZooming = !1),
                            (this.raf = null),
                            (this.G = null),
                            this.supportsTouch ||
                                (t.options.allowPanToNext = !1),
                            (this.drag = new (class t {
                                constructor(t) {
                                    (this.gestures = t),
                                        (this.pswp = t.pswp),
                                        (this.startPan = { x: 0, y: 0 });
                                }
                                start() {
                                    this.pswp.currSlide &&
                                        i(
                                            this.startPan,
                                            this.pswp.currSlide.pan
                                        ),
                                        this.pswp.animations.stopAll();
                                }
                                change() {
                                    let {
                                            p1: t,
                                            prevP1: i,
                                            dragAxis: s,
                                        } = this.gestures,
                                        { currSlide: n } = this.pswp;
                                    if (
                                        "y" === s &&
                                        this.pswp.options.closeOnVerticalDrag &&
                                        n &&
                                        n.currZoomLevel <= n.zoomLevels.fit &&
                                        !this.gestures.isMultitouch
                                    ) {
                                        let h = n.pan.y + (t.y - i.y);
                                        if (
                                            !this.pswp.dispatch(
                                                "verticalDrag",
                                                { panY: h }
                                            ).defaultPrevented
                                        ) {
                                            this._("y", h, 0.6);
                                            let o =
                                                1 - Math.abs(this.S(n.pan.y));
                                            this.pswp.applyBgOpacity(o),
                                                n.applyCurrentZoomPan();
                                        }
                                    } else
                                        this.M("x") ||
                                            (this.M("y"),
                                            n &&
                                                (e(n.pan),
                                                n.applyCurrentZoomPan()));
                                }
                                end() {
                                    let { velocity: t } = this.gestures,
                                        { mainScroll: i, currSlide: e } =
                                            this.pswp,
                                        s = 0;
                                    if (
                                        (this.pswp.animations.stopAll(),
                                        i.isShifted())
                                    ) {
                                        let n =
                                            (i.x - i.getCurrSlideX()) /
                                            this.pswp.viewportSize.x;
                                        (t.x < -0.5 && n < 0) ||
                                        (t.x < 0.1 && n < -0.5)
                                            ? ((s = 1),
                                              (t.x = Math.min(t.x, 0)))
                                            : ((t.x > 0.5 && n > 0) ||
                                                  (t.x > -0.1 && n > 0.5)) &&
                                              ((s = -1),
                                              (t.x = Math.max(t.x, 0))),
                                            i.moveIndexBy(s, !0, t.x);
                                    }
                                    (e && e.currZoomLevel > e.zoomLevels.max) ||
                                    this.gestures.isMultitouch
                                        ? this.gestures.zoomLevels.correctZoomPan(
                                              !0
                                          )
                                        : (this.P("x"), this.P("y"));
                                }
                                P(t) {
                                    var i;
                                    let { velocity: e } = this.gestures,
                                        { currSlide: s } = this.pswp;
                                    if (!s) return;
                                    let { pan: n, bounds: o } = s,
                                        r = n[t],
                                        a =
                                            this.pswp.bgOpacity < 1 &&
                                            "y" === t,
                                        l =
                                            r +
                                            (0.995 * (i = e[t])) / (1 - 0.995);
                                    if (a) {
                                        let p = this.S(r),
                                            d = this.S(l);
                                        if (
                                            (p < 0 && d < -0.4) ||
                                            (p > 0 && d > 0.4)
                                        )
                                            return void this.pswp.close();
                                    }
                                    let c = o.correctPan(t, l);
                                    if (r === c) return;
                                    let m = this.pswp.bgOpacity,
                                        u = c - r;
                                    this.pswp.animations.startSpring({
                                        name: "panGesture" + t,
                                        isPan: !0,
                                        start: r,
                                        end: c,
                                        velocity: e[t],
                                        dampingRatio: c === l ? 1 : 0.82,
                                        onUpdate: (i) => {
                                            a &&
                                                this.pswp.bgOpacity < 1 &&
                                                this.pswp.applyBgOpacity(
                                                    h(
                                                        m +
                                                            (1 - m) *
                                                                (1 -
                                                                    (c - i) /
                                                                        u),
                                                        0,
                                                        1
                                                    )
                                                ),
                                                (n[t] = Math.floor(i)),
                                                s.applyCurrentZoomPan();
                                        },
                                    });
                                }
                                M(t) {
                                    let {
                                            p1: i,
                                            dragAxis: e,
                                            prevP1: s,
                                            isMultitouch: n,
                                        } = this.gestures,
                                        { currSlide: h, mainScroll: o } =
                                            this.pswp,
                                        r = i[t] - s[t],
                                        a = o.x + r;
                                    if (!r || !h) return !1;
                                    if ("x" === t && !h.isPannable() && !n)
                                        return o.moveTo(a, !0), !0;
                                    let { bounds: l } = h,
                                        p = h.pan[t] + r;
                                    if (
                                        this.pswp.options.allowPanToNext &&
                                        "x" === e &&
                                        "x" === t &&
                                        !n
                                    ) {
                                        let d = o.getCurrSlideX(),
                                            c = o.x - d,
                                            m = r > 0;
                                        if (p > l.min[t] && m) {
                                            if (l.min[t] <= this.startPan[t])
                                                return o.moveTo(a, !0), !0;
                                            this._(t, p);
                                        } else if (p < l.max[t] && !m) {
                                            if (this.startPan[t] <= l.max[t])
                                                return o.moveTo(a, !0), !0;
                                            this._(t, p);
                                        } else if (0 !== c) {
                                            if (c > 0)
                                                return (
                                                    o.moveTo(
                                                        Math.max(a, d),
                                                        !0
                                                    ),
                                                    !0
                                                );
                                            if (c < 0)
                                                return (
                                                    o.moveTo(
                                                        Math.min(a, d),
                                                        !0
                                                    ),
                                                    !0
                                                );
                                        } else this._(t, p);
                                    } else
                                        ("y" === t &&
                                            (o.isShifted() ||
                                                l.min.y === l.max.y)) ||
                                            this._(t, p);
                                    return !1;
                                }
                                S(t) {
                                    return (
                                        (t -
                                            (this.pswp.currSlide?.bounds.center
                                                .y ?? 0)) /
                                        (this.pswp.viewportSize.y / 3)
                                    );
                                }
                                _(t, i, e) {
                                    let { currSlide: s } = this.pswp;
                                    if (!s) return;
                                    let { pan: n, bounds: h } = s;
                                    if (h.correctPan(t, i) !== i || e) {
                                        let o = Math.round(i - n[t]);
                                        n[t] += o * (e || 0.35);
                                    } else n[t] = i;
                                }
                            })(this)),
                            (this.zoomLevels = new (class t {
                                constructor(t) {
                                    (this.gestures = t),
                                        (this.C = { x: 0, y: 0 }),
                                        (this.T = { x: 0, y: 0 }),
                                        (this.A = { x: 0, y: 0 }),
                                        (this.D = !1),
                                        (this.I = 1);
                                }
                                start() {
                                    let { currSlide: t } = this.gestures.pswp;
                                    t &&
                                        ((this.I = t.currZoomLevel),
                                        i(this.C, t.pan)),
                                        this.gestures.pswp.animations.stopAllPan(),
                                        (this.D = !1);
                                }
                                change() {
                                    let {
                                            p1: t,
                                            startP1: i,
                                            p2: e,
                                            startP2: n,
                                            pswp: h,
                                        } = this.gestures,
                                        { currSlide: o } = h;
                                    if (!o) return;
                                    let r = o.zoomLevels.min,
                                        a = o.zoomLevels.max;
                                    if (
                                        !o.isZoomable() ||
                                        h.mainScroll.isShifted()
                                    )
                                        return;
                                    x(this.T, i, n), x(this.A, t, e);
                                    let l = (1 / s(i, n)) * s(t, e) * this.I;
                                    if (
                                        (l >
                                            o.zoomLevels.initial +
                                                o.zoomLevels.initial / 15 &&
                                            (this.D = !0),
                                        l < r)
                                    ) {
                                        if (
                                            h.options.pinchToClose &&
                                            !this.D &&
                                            this.I <= o.zoomLevels.initial
                                        ) {
                                            let p = 1 - (r - l) / (r / 1.2);
                                            h.dispatch("pinchClose", {
                                                bgOpacity: p,
                                            }).defaultPrevented ||
                                                h.applyBgOpacity(p);
                                        } else l = r - 0.15 * (r - l);
                                    } else l > a && (l = a + 0.05 * (l - a));
                                    (o.pan.x = this.L("x", l)),
                                        (o.pan.y = this.L("y", l)),
                                        o.setZoomLevel(l),
                                        o.applyCurrentZoomPan();
                                }
                                end() {
                                    let { pswp: t } = this.gestures,
                                        { currSlide: i } = t;
                                    (!i ||
                                        i.currZoomLevel <
                                            i.zoomLevels.initial) &&
                                    !this.D &&
                                    t.options.pinchToClose
                                        ? t.close()
                                        : this.correctZoomPan();
                                }
                                L(t, i) {
                                    let e = i / this.I;
                                    return (
                                        this.A[t] - (this.T[t] - this.C[t]) * e
                                    );
                                }
                                correctZoomPan(t) {
                                    let { pswp: e } = this.gestures,
                                        { currSlide: s } = e;
                                    if (!s?.isZoomable()) return;
                                    0 === this.A.x && (t = !0);
                                    let o = s.currZoomLevel,
                                        r,
                                        a = !0;
                                    o < s.zoomLevels.initial
                                        ? (r = s.zoomLevels.initial)
                                        : o > s.zoomLevels.max
                                        ? (r = s.zoomLevels.max)
                                        : ((a = !1), (r = o));
                                    let l = e.bgOpacity,
                                        p = e.bgOpacity < 1,
                                        d = i({ x: 0, y: 0 }, s.pan),
                                        c = i({ x: 0, y: 0 }, d);
                                    t &&
                                        ((this.A.x = 0),
                                        (this.A.y = 0),
                                        (this.T.x = 0),
                                        (this.T.y = 0),
                                        (this.I = o),
                                        i(this.C, d)),
                                        a &&
                                            (c = {
                                                x: this.L("x", r),
                                                y: this.L("y", r),
                                            }),
                                        s.setZoomLevel(r),
                                        (c = {
                                            x: s.bounds.correctPan("x", c.x),
                                            y: s.bounds.correctPan("y", c.y),
                                        }),
                                        s.setZoomLevel(o);
                                    let m = !n(c, d);
                                    if (!m && !a && !p)
                                        return (
                                            s.g(r), void s.applyCurrentZoomPan()
                                        );
                                    e.animations.stopAllPan(),
                                        e.animations.startSpring({
                                            isPan: !0,
                                            start: 0,
                                            end: 1e3,
                                            velocity: 0,
                                            dampingRatio: 1,
                                            naturalFrequency: 40,
                                            onUpdate(t) {
                                                if (((t /= 1e3), m || a)) {
                                                    if (
                                                        (m &&
                                                            ((s.pan.x =
                                                                d.x +
                                                                (c.x - d.x) *
                                                                    t),
                                                            (s.pan.y =
                                                                d.y +
                                                                (c.y - d.y) *
                                                                    t)),
                                                        a)
                                                    ) {
                                                        let i = o + (r - o) * t;
                                                        s.setZoomLevel(i);
                                                    }
                                                    s.applyCurrentZoomPan();
                                                }
                                                p &&
                                                    e.bgOpacity < 1 &&
                                                    e.applyBgOpacity(
                                                        h(l + (1 - l) * t, 0, 1)
                                                    );
                                            },
                                            onComplete() {
                                                s.g(r), s.applyCurrentZoomPan();
                                            },
                                        });
                                }
                            })(this)),
                            (this.tapHandler = new (class t {
                                constructor(t) {
                                    this.gestures = t;
                                }
                                click(t, i) {
                                    let e = i.target.classList,
                                        s = e.contains("pswp__img"),
                                        n =
                                            e.contains("pswp__item") ||
                                            e.contains("pswp__zoom-wrap");
                                    s
                                        ? this.k("imageClick", t, i)
                                        : n && this.k("bgClick", t, i);
                                }
                                tap(t, i) {
                                    _(i) && this.k("tap", t, i);
                                }
                                doubleTap(t, i) {
                                    _(i) && this.k("doubleTap", t, i);
                                }
                                k(t, i, e) {
                                    let { pswp: s } = this.gestures,
                                        { currSlide: n } = s,
                                        h = t + "Action",
                                        o = s.options[h];
                                    if (
                                        !s.dispatch(h, {
                                            point: i,
                                            originalEvent: e,
                                        }).defaultPrevented
                                    ) {
                                        if ("function" != typeof o)
                                            switch (o) {
                                                case "close":
                                                case "next":
                                                    s[o]();
                                                    break;
                                                case "zoom":
                                                    n?.toggleZoom(i);
                                                    break;
                                                case "zoom-or-close":
                                                    n?.isZoomable() &&
                                                    n.zoomLevels.secondary !==
                                                        n.zoomLevels.initial
                                                        ? n.toggleZoom(i)
                                                        : s.options
                                                              .clickToCloseNonZoomable &&
                                                          s.close();
                                                    break;
                                                case "toggle-controls":
                                                    this.gestures.pswp.element?.classList.toggle(
                                                        "pswp--ui-visible"
                                                    );
                                            }
                                        else o.call(s, i, e);
                                    }
                                }
                            })(this)),
                            t.on("bindEvents", () => {
                                t.events.add(
                                    t.scrollWrap,
                                    "click",
                                    this.$.bind(this)
                                ),
                                    this.N
                                        ? this.q(
                                              "pointer",
                                              "down",
                                              "up",
                                              "cancel"
                                          )
                                        : this.R
                                        ? (this.q(
                                              "touch",
                                              "start",
                                              "end",
                                              "cancel"
                                          ),
                                          t.scrollWrap &&
                                              ((t.scrollWrap.ontouchmove =
                                                  () => {}),
                                              (t.scrollWrap.ontouchend =
                                                  () => {})))
                                        : this.q("mouse", "down", "up");
                            });
                    }
                    q(t, i, e, s) {
                        let { pswp: n } = this,
                            { events: h } = n,
                            o = s ? t + s : "";
                        h.add(
                            n.scrollWrap,
                            t + i,
                            this.onPointerDown.bind(this)
                        ),
                            h.add(
                                window,
                                t + "move",
                                this.onPointerMove.bind(this)
                            ),
                            h.add(window, t + e, this.onPointerUp.bind(this)),
                            o &&
                                h.add(
                                    n.scrollWrap,
                                    o,
                                    this.onPointerUp.bind(this)
                                );
                    }
                    onPointerDown(t) {
                        let e =
                            "mousedown" === t.type || "mouse" === t.pointerType;
                        if (e && t.button > 0) return;
                        let { pswp: s } = this;
                        s.opener.isOpen
                            ? s.dispatch("pointerDown", { originalEvent: t })
                                  .defaultPrevented ||
                              (e && (s.mouseDetected(), this.H(t)),
                              s.animations.stopAll(),
                              this.K(t, "down"),
                              1 === this.F &&
                                  ((this.dragAxis = null),
                                  i(this.startP1, this.p1)),
                              this.F > 1
                                  ? (this.W(), (this.isMultitouch = !0))
                                  : (this.isMultitouch = !1))
                            : t.preventDefault();
                    }
                    onPointerMove(t) {
                        t.preventDefault(),
                            this.F &&
                                (this.K(t, "move"),
                                this.pswp.dispatch("pointerMove", {
                                    originalEvent: t,
                                }).defaultPrevented ||
                                    (1 !== this.F || this.isDragging
                                        ? this.F > 1 &&
                                          !this.isZooming &&
                                          (this.j(),
                                          (this.isZooming = !0),
                                          this.X(),
                                          this.zoomLevels.start(),
                                          this.Y(),
                                          this.J())
                                        : (this.dragAxis || this.tt(),
                                          this.dragAxis &&
                                              !this.isDragging &&
                                              (this.isZooming &&
                                                  ((this.isZooming = !1),
                                                  this.zoomLevels.end()),
                                              (this.isDragging = !0),
                                              this.W(),
                                              this.X(),
                                              (this.U = Date.now()),
                                              (this.V = !1),
                                              i(this.B, this.p1),
                                              (this.velocity.x = 0),
                                              (this.velocity.y = 0),
                                              this.drag.start(),
                                              this.Y(),
                                              this.J()))));
                    }
                    j() {
                        this.isDragging &&
                            ((this.isDragging = !1),
                            this.V || this.it(!0),
                            this.drag.end(),
                            (this.dragAxis = null));
                    }
                    onPointerUp(t) {
                        this.F &&
                            (this.K(t, "up"),
                            this.pswp.dispatch("pointerUp", {
                                originalEvent: t,
                            }).defaultPrevented ||
                                (0 === this.F &&
                                    (this.Y(),
                                    this.isDragging
                                        ? this.j()
                                        : this.isZooming ||
                                          this.isMultitouch ||
                                          this.st(t)),
                                this.F < 2 &&
                                    this.isZooming &&
                                    ((this.isZooming = !1),
                                    this.zoomLevels.end(),
                                    1 === this.F &&
                                        ((this.dragAxis = null), this.X()))));
                    }
                    J() {
                        (this.isDragging || this.isZooming) &&
                            (this.it(),
                            this.isDragging
                                ? n(this.p1, this.prevP1) || this.drag.change()
                                : (n(this.p1, this.prevP1) &&
                                      n(this.p2, this.prevP2)) ||
                                  this.zoomLevels.change(),
                            this.ht(),
                            (this.raf = requestAnimationFrame(
                                this.J.bind(this)
                            )));
                    }
                    it(t) {
                        let e = Date.now(),
                            s = e - this.U;
                        (s < 50 && !t) ||
                            ((this.velocity.x = this.et("x", s)),
                            (this.velocity.y = this.et("y", s)),
                            (this.U = e),
                            i(this.B, this.p1),
                            (this.V = !0));
                    }
                    st(t) {
                        let { mainScroll: e } = this.pswp;
                        if (e.isShifted()) return void e.moveIndexBy(0, !0);
                        if (t.type.indexOf("cancel") > 0) return;
                        if ("mouseup" === t.type || "mouse" === t.pointerType)
                            return void this.tapHandler.click(this.startP1, t);
                        let n = this.pswp.options.doubleTapAction ? 300 : 0;
                        this.G
                            ? (this.W(),
                              25 > s(this.Z, this.startP1) &&
                                  this.tapHandler.doubleTap(this.startP1, t))
                            : (i(this.Z, this.startP1),
                              (this.G = setTimeout(() => {
                                  this.tapHandler.tap(this.startP1, t),
                                      this.W();
                              }, n)));
                    }
                    W() {
                        this.G && (clearTimeout(this.G), (this.G = null));
                    }
                    et(t, i) {
                        let e = this.p1[t] - this.B[t];
                        return Math.abs(e) > 1 && i > 5 ? e / i : 0;
                    }
                    Y() {
                        this.raf &&
                            (cancelAnimationFrame(this.raf), (this.raf = null));
                    }
                    H(t) {
                        t.preventDefault();
                    }
                    K(t, e) {
                        if (this.N) {
                            let s = t,
                                n = this.O.findIndex(
                                    (t) => t.id === s.pointerId
                                );
                            "up" === e && n > -1
                                ? this.O.splice(n, 1)
                                : "down" === e && -1 === n
                                ? this.O.push(this.nt(s, { x: 0, y: 0 }))
                                : n > -1 && this.nt(s, this.O[n]),
                                (this.F = this.O.length),
                                this.F > 0 && i(this.p1, this.O[0]),
                                this.F > 1 && i(this.p2, this.O[1]);
                        } else {
                            let h = t;
                            (this.F = 0),
                                h.type.indexOf("touch") > -1
                                    ? h.touches &&
                                      h.touches.length > 0 &&
                                      (this.nt(h.touches[0], this.p1),
                                      this.F++,
                                      h.touches.length > 1 &&
                                          (this.nt(h.touches[1], this.p2),
                                          this.F++))
                                    : (this.nt(t, this.p1),
                                      "up" === e ? (this.F = 0) : this.F++);
                        }
                    }
                    ht() {
                        i(this.prevP1, this.p1), i(this.prevP2, this.p2);
                    }
                    X() {
                        i(this.startP1, this.p1),
                            i(this.startP2, this.p2),
                            this.ht();
                    }
                    tt() {
                        if (this.pswp.mainScroll.isShifted())
                            this.dragAxis = "x";
                        else {
                            let t =
                                Math.abs(this.p1.x - this.startP1.x) -
                                Math.abs(this.p1.y - this.startP1.y);
                            if (0 !== t) {
                                let i = t > 0 ? "x" : "y";
                                Math.abs(this.p1[i] - this.startP1[i]) >= 10 &&
                                    (this.dragAxis = i);
                            }
                        }
                    }
                    nt(t, i) {
                        return (
                            (i.x = t.pageX - this.pswp.offset.x),
                            (i.y = t.pageY - this.pswp.offset.y),
                            "pointerId" in t
                                ? (i.id = t.pointerId)
                                : void 0 !== t.identifier &&
                                  (i.id = t.identifier),
                            i
                        );
                    }
                    $(t) {
                        this.pswp.mainScroll.isShifted() &&
                            (t.preventDefault(), t.stopPropagation());
                    }
                })(this)),
                (this.opener = new (class t {
                    constructor(t) {
                        (this.pswp = t),
                            (this.isClosed = !0),
                            (this.isOpen = !1),
                            (this.isClosing = !1),
                            (this.isOpening = !1),
                            (this.It = void 0),
                            (this.Et = !1),
                            (this.Lt = !1),
                            (this.kt = !1),
                            (this.Zt = !1),
                            (this.Bt = void 0),
                            (this.Ft = void 0),
                            (this.Ot = void 0),
                            (this.Rt = void 0),
                            (this.Nt = void 0),
                            (this.Ut = this.Ut.bind(this)),
                            t.on("firstZoomPan", this.Ut);
                    }
                    open() {
                        this.Ut(), this.Pt();
                    }
                    close() {
                        if (this.isClosed || this.isClosing || this.isOpening)
                            return;
                        let t = this.pswp.currSlide;
                        (this.isOpen = !1),
                            (this.isOpening = !1),
                            (this.isClosing = !0),
                            (this.It = this.pswp.options.hideAnimationDuration),
                            t &&
                                t.currZoomLevel * t.width >=
                                    this.pswp.options.maxWidthToAnimate &&
                                (this.It = 0),
                            this.Vt(),
                            setTimeout(
                                () => {
                                    this.Pt();
                                },
                                this.Lt ? 30 : 0
                            );
                    }
                    Ut() {
                        if (
                            (this.pswp.off("firstZoomPan", this.Ut),
                            !this.isOpening)
                        ) {
                            let t = this.pswp.currSlide;
                            (this.isOpening = !0),
                                (this.isClosing = !1),
                                (this.It =
                                    this.pswp.options.showAnimationDuration),
                                t &&
                                    t.zoomLevels.initial * t.width >=
                                        this.pswp.options.maxWidthToAnimate &&
                                    (this.It = 0),
                                this.Vt();
                        }
                    }
                    Vt() {
                        let { pswp: t } = this,
                            i = this.pswp.currSlide,
                            { options: e } = t;
                        if (
                            ("fade" === e.showHideAnimationType
                                ? ((e.showHideOpacity = !0), (this.Nt = void 0))
                                : "none" === e.showHideAnimationType
                                ? ((e.showHideOpacity = !1),
                                  (this.It = 0),
                                  (this.Nt = void 0))
                                : this.isOpening && t.Gt
                                ? (this.Nt = t.Gt)
                                : (this.Nt = this.pswp.getThumbBounds()),
                            (this.Bt = i?.getPlaceholderElement()),
                            t.animations.stopAll(),
                            (this.Et = Boolean(this.It && this.It > 50)),
                            (this.$t =
                                Boolean(this.Nt) &&
                                i?.content.usePlaceholder() &&
                                (!this.isClosing || !t.mainScroll.isShifted())),
                            this.$t
                                ? (this.kt = e.showHideOpacity ?? !1)
                                : ((this.kt = !0),
                                  this.isOpening &&
                                      i &&
                                      (i.zoomAndPanToInitial(),
                                      i.applyCurrentZoomPan())),
                            (this.Zt =
                                !this.kt &&
                                this.pswp.options.bgOpacity > 0.003),
                            (this.Ft = this.kt ? t.element : t.bg),
                            !this.Et)
                        )
                            return (
                                (this.It = 0),
                                (this.$t = !1),
                                (this.Zt = !1),
                                (this.kt = !0),
                                void (
                                    this.isOpening &&
                                    (t.element &&
                                        (t.element.style.opacity =
                                            String(0.003)),
                                    t.applyBgOpacity(1))
                                )
                            );
                        this.$t && this.Nt && this.Nt.innerRect
                            ? ((this.Lt = !0),
                              (this.Ot = this.pswp.container),
                              (this.Rt = this.pswp.currSlide?.holderElement),
                              t.container &&
                                  ((t.container.style.overflow = "hidden"),
                                  (t.container.style.width =
                                      t.viewportSize.x + "px")))
                            : (this.Lt = !1),
                            this.isOpening
                                ? (this.kt
                                      ? (t.element &&
                                            (t.element.style.opacity =
                                                String(0.003)),
                                        t.applyBgOpacity(1))
                                      : (this.Zt &&
                                            t.bg &&
                                            (t.bg.style.opacity =
                                                String(0.003)),
                                        t.element &&
                                            (t.element.style.opacity = "1")),
                                  this.$t &&
                                      (this.qt(),
                                      this.Bt &&
                                          ((this.Bt.style.willChange =
                                              "transform"),
                                          (this.Bt.style.opacity =
                                              String(0.003)))))
                                : this.isClosing &&
                                  (t.mainScroll.itemHolders[0] &&
                                      (t.mainScroll.itemHolders[0].el.style.display =
                                          "none"),
                                  t.mainScroll.itemHolders[2] &&
                                      (t.mainScroll.itemHolders[2].el.style.display =
                                          "none"),
                                  this.Lt &&
                                      0 !== t.mainScroll.x &&
                                      (t.mainScroll.resetPosition(),
                                      t.mainScroll.resize()));
                    }
                    Pt() {
                        this.isOpening &&
                        this.Et &&
                        this.Bt &&
                        "IMG" === this.Bt.tagName
                            ? new Promise((t) => {
                                  var i;
                                  let e = !1,
                                      s = !0;
                                  ("decode" in (i = this.Bt)
                                      ? i.decode().catch(() => {})
                                      : i.complete
                                      ? Promise.resolve(i)
                                      : new Promise((t, e) => {
                                            (i.onload = () => t(i)),
                                                (i.onerror = e);
                                        })
                                  ).finally(() => {
                                      (e = !0), s || t(!0);
                                  }),
                                      setTimeout(() => {
                                          (s = !1), e && t(!0);
                                      }, 50),
                                      setTimeout(t, 250);
                              }).finally(() => this.Ht())
                            : this.Ht();
                    }
                    Ht() {
                        this.pswp.element?.style.setProperty(
                            "--pswp-transition-duration",
                            this.It + "ms"
                        ),
                            this.pswp.dispatch(
                                this.isOpening
                                    ? "openingAnimationStart"
                                    : "closingAnimationStart"
                            ),
                            this.pswp.dispatch(
                                "initialZoom" + (this.isOpening ? "In" : "Out")
                            ),
                            this.pswp.element?.classList.toggle(
                                "pswp--ui-visible",
                                this.isOpening
                            ),
                            this.isOpening
                                ? (this.Bt && (this.Bt.style.opacity = "1"),
                                  this.Kt())
                                : this.isClosing && this.Wt(),
                            this.Et || this.jt();
                    }
                    jt() {
                        let { pswp: t } = this;
                        (this.isOpen = this.isOpening),
                            (this.isClosed = this.isClosing),
                            (this.isOpening = !1),
                            (this.isClosing = !1),
                            t.dispatch(
                                this.isOpen
                                    ? "openingAnimationEnd"
                                    : "closingAnimationEnd"
                            ),
                            t.dispatch(
                                "initialZoom" +
                                    (this.isOpen ? "InEnd" : "OutEnd")
                            ),
                            this.isClosed
                                ? t.destroy()
                                : this.isOpen &&
                                  (this.$t &&
                                      t.container &&
                                      ((t.container.style.overflow = "visible"),
                                      (t.container.style.width = "100%")),
                                  t.currSlide?.applyCurrentZoomPan());
                    }
                    Kt() {
                        let { pswp: t } = this;
                        this.$t &&
                            (this.Lt &&
                                this.Ot &&
                                this.Rt &&
                                (this.Xt(
                                    this.Ot,
                                    "transform",
                                    "translate3d(0,0,0)"
                                ),
                                this.Xt(this.Rt, "transform", "none")),
                            t.currSlide &&
                                (t.currSlide.zoomAndPanToInitial(),
                                this.Xt(
                                    t.currSlide.container,
                                    "transform",
                                    t.currSlide.getCurrentTransform()
                                ))),
                            this.Zt &&
                                t.bg &&
                                this.Xt(
                                    t.bg,
                                    "opacity",
                                    String(t.options.bgOpacity)
                                ),
                            this.kt &&
                                t.element &&
                                this.Xt(t.element, "opacity", "1");
                    }
                    Wt() {
                        let { pswp: t } = this;
                        this.$t && this.qt(!0),
                            this.Zt &&
                                t.bgOpacity > 0.01 &&
                                t.bg &&
                                this.Xt(t.bg, "opacity", "0"),
                            this.kt &&
                                t.element &&
                                this.Xt(t.element, "opacity", "0");
                    }
                    qt(t) {
                        if (!this.Nt) return;
                        let { pswp: e } = this,
                            { innerRect: s } = this.Nt,
                            { currSlide: n, viewportSize: h } = e;
                        if (this.Lt && s && this.Ot && this.Rt) {
                            let a = -h.x + (this.Nt.x - s.x) + s.w,
                                l = -h.y + (this.Nt.y - s.y) + s.h,
                                p = h.x - s.w,
                                d = h.y - s.h;
                            t
                                ? (this.Xt(this.Ot, "transform", o(a, l)),
                                  this.Xt(this.Rt, "transform", o(p, d)))
                                : (r(this.Ot, a, l), r(this.Rt, p, d));
                        }
                        n &&
                            (i(n.pan, s || this.Nt),
                            (n.currZoomLevel = this.Nt.w / n.width),
                            t
                                ? this.Xt(
                                      n.container,
                                      "transform",
                                      n.getCurrentTransform()
                                  )
                                : n.applyCurrentZoomPan());
                    }
                    Xt(t, i, e) {
                        if (!this.It) return void (t.style[i] = e);
                        let { animations: s } = this.pswp,
                            n = {
                                duration: this.It,
                                easing: this.pswp.options.easing,
                                onComplete: () => {
                                    s.activeAnimations.length || this.jt();
                                },
                                target: t,
                            };
                        (n[i] = e), s.startTransition(n);
                    }
                })(this)),
                (this.keyboard = new (class t {
                    constructor(t) {
                        (this.pswp = t),
                            (this.lt = !1),
                            t.on("bindEvents", () => {
                                t.options.initialPointerPos || this.ut(),
                                    t.events.add(
                                        document,
                                        "focusin",
                                        this.dt.bind(this)
                                    ),
                                    t.events.add(
                                        document,
                                        "keydown",
                                        this.ft.bind(this)
                                    );
                            });
                        let i = document.activeElement;
                        t.on("destroy", () => {
                            t.options.returnFocus && i && this.lt && i.focus();
                        });
                    }
                    ut() {
                        !this.lt &&
                            this.pswp.element &&
                            (this.pswp.element.focus(), (this.lt = !0));
                    }
                    ft(t) {
                        var i;
                        let { pswp: e } = this;
                        if (
                            e.dispatch("keydown", { originalEvent: t })
                                .defaultPrevented ||
                            ("button" in (i = t) && 1 === i.button) ||
                            i.ctrlKey ||
                            i.metaKey ||
                            i.altKey ||
                            i.shiftKey
                        )
                            return;
                        let s,
                            n,
                            h = !1,
                            o = "key" in t;
                        switch (o ? t.key : t.keyCode) {
                            case b("Escape", o):
                                e.options.escKey && (s = "close");
                                break;
                            case b("z", o):
                                s = "toggleZoom";
                                break;
                            case b("ArrowLeft", o):
                                n = "x";
                                break;
                            case b("ArrowUp", o):
                                n = "y";
                                break;
                            case b("ArrowRight", o):
                                (n = "x"), (h = !0);
                                break;
                            case b("ArrowDown", o):
                                (h = !0), (n = "y");
                                break;
                            case b("Tab", o):
                                this.ut();
                        }
                        if (n) {
                            t.preventDefault();
                            let { currSlide: r } = e;
                            e.options.arrowKeys &&
                            "x" === n &&
                            e.getNumItems() > 1
                                ? (s = h ? "next" : "prev")
                                : r &&
                                  r.currZoomLevel > r.zoomLevels.fit &&
                                  ((r.pan[n] += h ? -80 : 80),
                                  r.panTo(r.pan.x, r.pan.y));
                        }
                        s && (t.preventDefault(), e[s]());
                    }
                    dt(t) {
                        let { template: i } = this.pswp;
                        i &&
                            document !== t.target &&
                            i !== t.target &&
                            !i.contains(t.target) &&
                            i.focus();
                    }
                })(this)),
                (this.contentLoader = new (class t {
                    constructor(t) {
                        (this.pswp = t),
                            (this.limit = Math.max(
                                t.options.preload[0] + t.options.preload[1] + 1,
                                5
                            )),
                            (this.Dt = []);
                    }
                    updateLazy(t) {
                        let { pswp: i } = this;
                        if (i.dispatch("lazyLoad").defaultPrevented) return;
                        let { preload: e } = i.options,
                            s = void 0 === t || t >= 0,
                            n;
                        for (n = 0; n <= e[1]; n++)
                            this.loadSlideByIndex(i.currIndex + (s ? n : -n));
                        for (n = 1; n <= e[0]; n++)
                            this.loadSlideByIndex(i.currIndex + (s ? -n : n));
                    }
                    loadSlideByIndex(t) {
                        let i = this.pswp.getLoopedIndex(t),
                            e = this.getContentByIndex(i);
                        e ||
                            ((e = (function (t, i) {
                                let e = i.getItemData(t);
                                if (
                                    !i.dispatch("lazyLoadSlide", {
                                        index: t,
                                        itemData: e,
                                    }).defaultPrevented
                                )
                                    return W(e, i, t);
                            })(i, this.pswp)) &&
                                this.addToCache(e));
                    }
                    getContentBySlide(t) {
                        let i = this.getContentByIndex(t.index);
                        return (
                            i ||
                                ((i = this.pswp.createContentFromData(
                                    t.data,
                                    t.index
                                )),
                                this.addToCache(i)),
                            i.setSlide(t),
                            i
                        );
                    }
                    addToCache(t) {
                        if (
                            (this.removeByIndex(t.index),
                            this.Dt.push(t),
                            this.Dt.length > this.limit)
                        ) {
                            let i = this.Dt.findIndex(
                                (t) => !t.isAttached && !t.hasSlide
                            );
                            -1 !== i && this.Dt.splice(i, 1)[0].destroy();
                        }
                    }
                    removeByIndex(t) {
                        let i = this.Dt.findIndex((i) => i.index === t);
                        -1 !== i && this.Dt.splice(i, 1);
                    }
                    getContentByIndex(t) {
                        return this.Dt.find((i) => i.index === t);
                    }
                    destroy() {
                        this.Dt.forEach((t) => t.destroy()), (this.Dt = []);
                    }
                })(this));
        }
        init() {
            if (this.isOpen || this.isDestroying) return !1;
            (this.isOpen = !0),
                this.dispatch("init"),
                this.dispatch("beforeOpen"),
                this.ei();
            let t = "pswp--open";
            return (
                this.gestures.supportsTouch && (t += " pswp--touch"),
                this.options.mainClass && (t += " " + this.options.mainClass),
                this.element && (this.element.className += " " + t),
                (this.currIndex = this.options.index || 0),
                (this.potentialIndex = this.currIndex),
                this.dispatch("firstUpdate"),
                (this.scrollWheel = new I(this)),
                (Number.isNaN(this.currIndex) ||
                    this.currIndex < 0 ||
                    this.currIndex >= this.getNumItems()) &&
                    (this.currIndex = 0),
                this.gestures.supportsTouch || this.mouseDetected(),
                this.updateSize(),
                (this.offset.y = window.pageYOffset),
                (this.hi = this.getItemData(this.currIndex)),
                this.dispatch("gettingData", {
                    index: this.currIndex,
                    data: this.hi,
                    slide: void 0,
                }),
                (this.Gt = this.getThumbBounds()),
                this.dispatch("initialLayout"),
                this.on("openingAnimationEnd", () => {
                    let { itemHolders: t } = this.mainScroll;
                    t[0] &&
                        ((t[0].el.style.display = "block"),
                        this.setContent(t[0], this.currIndex - 1)),
                        t[2] &&
                            ((t[2].el.style.display = "block"),
                            this.setContent(t[2], this.currIndex + 1)),
                        this.appendHeavy(),
                        this.contentLoader.updateLazy(),
                        this.events.add(window, "resize", this.ni.bind(this)),
                        this.events.add(window, "scroll", this.oi.bind(this)),
                        this.dispatch("bindEvents");
                }),
                this.mainScroll.itemHolders[1] &&
                    this.setContent(
                        this.mainScroll.itemHolders[1],
                        this.currIndex
                    ),
                this.dispatch("change"),
                this.opener.open(),
                this.dispatch("afterInit"),
                !0
            );
        }
        getLoopedIndex(t) {
            let i = this.getNumItems();
            return (
                this.options.loop && (t > i - 1 && (t -= i), t < 0 && (t += i)),
                h(t, 0, i - 1)
            );
        }
        appendHeavy() {
            this.mainScroll.itemHolders.forEach((t) => {
                t.slide?.appendHeavy();
            });
        }
        goTo(t) {
            this.mainScroll.moveIndexBy(
                this.getLoopedIndex(t) - this.potentialIndex
            );
        }
        next() {
            this.goTo(this.potentialIndex + 1);
        }
        prev() {
            this.goTo(this.potentialIndex - 1);
        }
        zoomTo(...t) {
            this.currSlide?.zoomTo(...t);
        }
        toggleZoom() {
            this.currSlide?.toggleZoom();
        }
        close() {
            this.opener.isOpen &&
                !this.isDestroying &&
                ((this.isDestroying = !0),
                this.dispatch("close"),
                this.events.removeAll(),
                this.opener.close());
        }
        destroy() {
            if (!this.isDestroying)
                return (
                    (this.options.showHideAnimationType = "none"),
                    void this.close()
                );
            this.dispatch("destroy"),
                (this.Yt = {}),
                this.scrollWrap &&
                    ((this.scrollWrap.ontouchmove = null),
                    (this.scrollWrap.ontouchend = null)),
                this.element?.remove(),
                this.mainScroll.itemHolders.forEach((t) => {
                    t.slide?.destroy();
                }),
                this.contentLoader.destroy(),
                this.events.removeAll();
        }
        refreshSlideContent(t) {
            this.contentLoader.removeByIndex(t),
                this.mainScroll.itemHolders.forEach((i, e) => {
                    let s = (this.currSlide?.index ?? 0) - 1 + e;
                    this.canLoop() && (s = this.getLoopedIndex(s)),
                        s === t &&
                            (this.setContent(i, t, !0),
                            1 === e &&
                                ((this.currSlide = i.slide),
                                i.slide?.setIsActive(!0)));
                }),
                this.dispatch("change");
        }
        setContent(t, i, e) {
            if ((this.canLoop() && (i = this.getLoopedIndex(i)), t.slide)) {
                if (t.slide.index === i && !e) return;
                t.slide.destroy(), (t.slide = void 0);
            }
            if (!this.canLoop() && (i < 0 || i >= this.getNumItems())) return;
            let s = this.getItemData(i);
            (t.slide = new f(s, i, this)),
                i === this.currIndex && (this.currSlide = t.slide),
                t.slide.append(t.el);
        }
        getViewportCenterPoint() {
            return { x: this.viewportSize.x / 2, y: this.viewportSize.y / 2 };
        }
        updateSize(t) {
            if (this.isDestroying) return;
            let e = y(this.options, this);
            (!t && n(e, this.si)) ||
                (i(this.si, e),
                this.dispatch("beforeResize"),
                i(this.viewportSize, this.si),
                this.oi(),
                this.dispatch("viewportSize"),
                this.mainScroll.resize(this.opener.isOpen),
                !this.hasMouse &&
                    window.matchMedia("(any-hover: hover)").matches &&
                    this.mouseDetected(),
                this.dispatch("resize"));
        }
        applyBgOpacity(t) {
            (this.bgOpacity = Math.max(t, 0)),
                this.bg &&
                    (this.bg.style.opacity = String(
                        this.bgOpacity * this.options.bgOpacity
                    ));
        }
        mouseDetected() {
            this.hasMouse ||
                ((this.hasMouse = !0),
                this.element?.classList.add("pswp--has_mouse"));
        }
        ni() {
            this.updateSize(),
                /iPhone|iPad|iPod/i.test(window.navigator.userAgent) &&
                    setTimeout(() => {
                        this.updateSize();
                    }, 500);
        }
        oi() {
            this.setScrollOffset(0, window.pageYOffset);
        }
        setScrollOffset(t, i) {
            (this.offset.x = t),
                (this.offset.y = i),
                this.dispatch("updateScrollOffset");
        }
        ei() {
            (this.element = t("pswp", "div")),
                this.element.setAttribute("tabindex", "-1"),
                this.element.setAttribute("role", "dialog"),
                (this.template = this.element),
                (this.bg = t("pswp__bg", "div", this.element)),
                (this.scrollWrap = t(
                    "pswp__scroll-wrap",
                    "section",
                    this.element
                )),
                (this.container = t("pswp__container", "div", this.scrollWrap)),
                this.scrollWrap.setAttribute(
                    "aria-roledescription",
                    "carousel"
                ),
                this.container.setAttribute("aria-live", "off"),
                this.container.setAttribute("id", "pswp__items"),
                this.mainScroll.appendHolders(),
                (this.ui = new B(this)),
                this.ui.init(),
                (this.options.appendToEl || document.body).appendChild(
                    this.element
                );
        }
        getThumbBounds() {
            return (function (t, i, e) {
                let s = e.dispatch("thumbBounds", {
                    index: t,
                    itemData: i,
                    instance: e,
                });
                if (s.thumbBounds) return s.thumbBounds;
                let { element: n } = i,
                    h,
                    o;
                if (n && !1 !== e.options.thumbSelector) {
                    let r = e.options.thumbSelector || "img";
                    o = n.matches(r) ? n : n.querySelector(r);
                }
                return (
                    (o = e.applyFilters("thumbEl", o, i, t)) &&
                        (h = i.thumbCropped
                            ? (function (t, i, e) {
                                  let s = t.getBoundingClientRect(),
                                      n = s.width / i,
                                      h = s.height / e,
                                      o = n > h ? n : h,
                                      r = (s.width - i * o) / 2,
                                      a = (s.height - e * o) / 2,
                                      l = {
                                          x: s.left + r,
                                          y: s.top + a,
                                          w: i * o,
                                      };
                                  return (
                                      (l.innerRect = {
                                          w: s.width,
                                          h: s.height,
                                          x: r,
                                          y: a,
                                      }),
                                      l
                                  );
                              })(o, i.width || i.w || 0, i.height || i.h || 0)
                            : (function (t) {
                                  let i = t.getBoundingClientRect();
                                  return { x: i.left, y: i.top, w: i.width };
                              })(o)),
                    e.applyFilters("thumbBounds", h, i, t)
                );
            })(
                this.currIndex,
                this.currSlide ? this.currSlide.data : this.hi,
                this
            );
        }
        canLoop() {
            return this.options.loop && this.getNumItems() > 2;
        }
        ii(t) {
            return (
                window.matchMedia("(prefers-reduced-motion), (update: slow)")
                    .matches &&
                    ((t.showHideAnimationType = "none"),
                    (t.zoomAnimationDuration = 0)),
                { ...M, ...t }
            );
        }
    };
});
